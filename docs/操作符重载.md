在 Python 中，“**操作符重载**” (Operator Overloading) 是一个非常强大的特性。

它**不是**指像 C++ 或 Java 中那样的“函数重载”（即根据参数类型或数量不同，定义同名函数）。Python 不直接支持那种函数重载。

相反，Python 的操作符重载允许您**重新定义**标准的 Python 操作符（如 `+`, `*`, `==`, `[]`）在**您自定义的类 (Class)** 上的行为。

### 核心原理：魔术方法 (Magic Methods)

实现操作符重载的核心是使用 Python 的\*\*“魔术方法”\*\*（也称为 "dunder" 方法，即 "double underscore" 双下划线）。

当您在类的实例上使用一个操作符时，Python 会自动将其“翻译”为对相应魔术方法的调用。

  * **当您写：** `a + b`
  * **Python 实际调用：** `a.__add__(b)`

通过在您的类中定义这些 `__xx__` 方法，您就可以“重载”这些操作符。

-----

### 一、 常见操作符重载示例

以下是最常用的几类操作符重载。

#### 1\. 初始化与表示 (Basic Methods)

这些是构建一个“好用”的类的基础。

  * `__init__(self, ...)`: **构造函数**。在 `obj = MyClass()` 时调用。
  * `__str__(self)`: 在 `str(obj)` 或 `print(obj)` 时调用。应返回一个**对用户友好**的字符串。
  * `__repr__(self)`: 在 `repr(obj)` 或在解释器中直接输入 `obj` 时调用。应返回一个**明确的、用于调试**的字符串，最好能重建该对象。

<!-- end list -->

```python
class MyClass:
    def __init__(self, value):
        self.value = value
    
    def __str__(self):
        return f"A pretty object with value {self.value}"
        
    def __repr__(self):
        return f"MyClass(value={self.value})"

>>> obj = MyClass(10)
>>> print(obj)  # 调用 __str__
A pretty object with value 10
>>> obj         # 调用 __repr__
MyClass(value=10)
```

#### 2\. 算术操作符 (Arithmetic Operators)

  * `__add__(self, other)`: `self + other`
  * `__sub__(self, other)`: `self - other`
  * `__mul__(self, other)`: `self * other`
  * `__truediv__(self, other)`: `self / other`
  * `__pow__(self, other)`: `self ** other`

**示例：二维向量 (Vector) 的加法**

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        # 确保我们是在和另一个 Vector 相加
        if isinstance(other, Vector):
            # 返回一个新的 Vector 实例
            return Vector(self.x + other.x, self.y + other.y)
        else:
            # 如果类型不匹配，返回 NotImplemented
            return NotImplemented

>>> v1 = Vector(1, 2)
>>> v2 = Vector(10, 20)
>>> print(v1 + v2)  # 调用 v1.__add__(v2)
Vector(11, 22)
```

#### 3\. 比较操作符 (Comparison Operators)

  * `__eq__(self, other)`: `self == other` (等于)
  * `__ne__(self, other)`: `self != other` (不等于)
  * `__lt__(self, other)`: `self < other` (小于)
  * `__gt__(self, other)`: `self > other` (大于)
  * `__le__(self, other)`: `self <= other` (小于等于)
  * `__ge__(self, other)`: `self >= other` (大于等于)

**提示：** 您不需要全部实现。通常，您只需实现 `__eq__` 和 `__lt__`，然后使用 `@functools.total_ordering` 装饰器，Python 会自动帮您实现其他所有比较操作。

**示例：比较金额 (Money)**

```python
class Money:
    def __init__(self, amount, currency):
        self.amount = amount
        self.currency = currency
        
    def __eq__(self, other):
        if isinstance(other, Money):
            return (self.amount == other.amount and 
                    self.currency == other.currency)
        return False
        
    def __gt__(self, other):
        if isinstance(other, Money) and self.currency == other.currency:
            return self.amount > other.amount
        return NotImplemented

>>> m1 = Money(100, "USD")
>>> m2 = Money(100, "USD")
>>> m3 = Money(50, "USD")
>>> print(m1 == m2)  # 调用 m1.__eq__(m2)
True
>>> print(m1 == m3)
False
>>> print(m1 > m3)   # 调用 m1.__gt__(m3)
True
```

#### 4\. "反向"算术操作符 (Reversed Operators)

上面的 `v1 + v2` 调用的是 `v1.__add__(v2)`。但如果您写 `5 + v1` 会发生什么？

`5` 是一个 `int`，`int` 的 `__add__` 方法不知道如何处理您的 `Vector` 对象。此时，Python 会“反过来”尝试调用 `v1` 的**反向加法**方法：`v1.__radd__(5)`。

  * `__radd__(self, other)`: `other + self`
  * `__rsub__(self, other)`: `other - self`
  * `__rmul__(self, other)`: `other * self`

<!-- end list -->

```python
class Vector:
    # ... (接上例) ...
    
    def __add__(self, other):
        # ... (同上) ...
        return Vector(self.x + other.x, self.y + other.y)

    def __radd__(self, other):
        # 当 Python 尝试 5 + v1 时
        # other 会是 5
        print(f"__radd__ 被调用, other = {other}")
        # 我们可以重用 __add__ 逻辑
        return self.__add__(Vector(other, other)) # 假设 5 + v1 等于 (5,5) + v1

>>> v1 = Vector(1, 2)
>>> print(5 + v1)
__radd__ 被调用, other = 5
Vector(6, 7)
```

#### 5\. 容器类操作符 (Container Operators)

  * `__len__(self)`: `len(obj)`
  * `__getitem__(self, key)`: `obj[key]` (获取元素，支持索引 `obj[0]` 或切片 `obj[1:3]`)
  * `__setitem__(self, key, value)`: `obj[key] = value` (设置元素)
  * `__delitem__(self, key)`: `del obj[key]` (删除元素)
  * `__contains__(self, item)`: `item in obj` (成员测试)

**示例：自定义列表**

```python
class MyList:
    def __init__(self, data):
        self._data = list(data)
        
    def __len__(self):
        return len(self._data)
        
    def __getitem__(self, index):
        return self._data[index]
        
    def __repr__(self):
        return repr(self._data)

>>> m = MyList([1, 10, 20, 30])
>>> print(len(m))    # 调用 __len__
4
>>> print(m[1])      # 调用 __getitem__(1)
10
>>> print(m[1:3])    # __getitem__ 也会自动处理切片
[10, 20]
```

#### 6\. 可调用对象 (Callable Objects)

  * `__call__(self, *args, **kwargs)`: `obj(arg1, arg2)`

这允许您将一个类的**实例**当作一个**函数**来“调用”。

```python
class Adder:
    def __init__(self, base):
        self.base = base
        
    def __call__(self, value):
        # 当实例被调用时，执行此操作
        return self.base + value

>>> add_five = Adder(5)
>>> print( add_five(10) )  # 调用 add_five.__call__(10)
15
>>> print( add_five(100) ) # 再次调用
105
```

-----

### 二、 常用魔术方法速查表

| 操作 | 魔术方法 | 描述 |
| :--- | :--- | :--- |
| **创建与销毁** | | |
| `obj = MyClass()` | `__init__(self, ...)` | 构造函数 |
| `del obj` | `__del__(self)` | 析构函数（很少使用） |
| **表示** | | |
| `str(obj)`, `print(obj)` | `__str__(self)` | 对用户友好的字符串 |
| `repr(obj)` | `__repr__(self)` | 对开发者友好的字符串 |
| `len(obj)` | `__len__(self)` | 返回长度 |
| **算术** | | |
| `a + b` | `__add__(self, other)` | 加法 |
| `a - b` | `__sub__(self, other)` | 减法 |
| `a * b` | `__mul__(self, other)` | 乘法 |
| `a / b` | `__truediv__(self, other)`| 除法 |
| `a // b` | `__floordiv__(self, other)`| 地板除 |
| `a % b` | `__mod__(self, other)` | 取模 |
| `a ** b` | `__pow__(self, other)` | 幂 |
| `b + a` (反向) | `__radd__(self, other)` | 反向加法 |
| **比较** | | |
| `a == b` | `__eq__(self, other)` | 等于 |
| `a != b` | `__ne__(self, other)` | 不等于 |
| `a < b` | `__lt__(self, other)` | 小于 |
| `a > b` | `__gt__(self, other)` | 大于 |
| `a <= b` | `__le__(self, other)` | 小于等于 |
| `a >= b` | `__ge__(self, other)` | 大于等于 |
| **容器** | | |
| `obj[key]` | `__getitem__(self, key)` | 获取项 |
| `obj[key] = value` | `__setitem__(self, key, value)`| 设置项 |
| `del obj[key]` | `__delitem__(self, key)`| 删除项 |
| `item in obj` | `__contains__(self, item)`| 成员测试 |
| `for x in obj` | `__iter__(self)` | 迭代器（应返回一个迭代器） |
| **可调用** | | |
| `obj(arg1, arg2)` | `__call__(self, ...)` | 将实例作为函数调用 |
| **上下文管理** | | |
| `with obj as x:` | `__enter__(self)` | `with` 语句进入 |
| (退出 with) | `__exit__(self, ...)` | `with` 语句退出（清理） |

-----

### 三、 使用原则

操作符重载非常强大，但也容易被滥用。请遵循“**最小惊讶原则**” (Principle of Least Astonishment)：

1.  **保持直观：** `+` 应该总是表示某种形式的“相加”或“合并”。不要用 `+` 来做删除操作，这会使代码极难阅读。
2.  **返回新实例：** 大多数算术操作（如 `__add__`）**不应该**修改 `self`（即`v1.x = ...`），而应该返回一个新的实例（`return Vector(...)`）。
3.  **使用 `NotImplemented`：** 如果您的操作符不支持与某个特定类型（如 `int`）的操作，请 `return NotImplemented`。这会给 Python 机会去尝试反向操作（如 `__radd__`）。